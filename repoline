#!/usr/bin/perl

use strict;
use warnings;

use Cwd qw/cwd/;
use File::Basename qw/dirname/;
use File::Path qw/mkpath/;

# TODO(sdh): Daemonize this so that we can have an async process always running
# to keep things up to date.  Then return very quickly with (potentially) partial
# information if the current info is stale [is there a way to watch a directory to
# invalidate our data as soon as it changes? e.g. when actively working in a repo,
# the immediate next prompt will often be wrong, but if we could detect the change
# as soon as it happens, we could possibly avoid showing the wrong data].

# Usage:
#   repoline prompt  -- prints a prompt string
# Options (SUBJECT TO CHANGE):
#   --dirs=DIRS   - a colon-separate list of top-level dirs for repository
#   --fg=CODE     - use a fixed color instead.
#   --bg=CODE     - use a fixed color instead.
#   --notouch     - does not touch the color files or make new ones.
#   --columns=COL - total number of columns.
#   --left=TEXT   - text for left bubble.
#   --right=TEXT  - text for right bubble.
#   --prompt=TEXT - text for actual prompt.
#   --style=STYLE - style for decoration (diag, box, or flag)
#   --sep=STYLE   - separator (triangle, round, fire...)
#
# All options can be specified with environment variables using a REPO_ prefix
# and the name in all caps.

# TODO(sdh): Support multiple bubbles, percent-codes for e.g. user/host, date/time,
# dir, abbrev-dir (optional function to call to abbreviate?), repo status, etc
#  -- probably by adding a "%s" or something to break between them?
#  -- conditional bubbles?  e.g. %?{foo:bar:baz} ??? expand recursively?
#     -> will probably end up changing expand() to return an array?
#     in particular, condition on whether we're in a repo or not? maybe what kind?

# TODO(sdh): Option to print top line to STDERR instead (to minimize prompt)
#     -- currently broken - how to deal with this?!?
#     -- want to be able to both PRINT and set the PROMPT
#     -- maybe pass to EVAL???
# TODO(sdh): Option to print \[ and \] needed for bash to handle ansi properly?

# TODO(sdh): Allow registering custom handlers to get repo info for different
# types of repos?  Easy enough to call asynchronously...?


# CONFIG: use perl plugins?
# Need an API
#  * register_repo_type('hg', sub {})
#    - maybe use a full-on class for this?
#    - predicate would maybe return a blessed object w/ API?
#    - what about collisions? how to resolve? order dependence?
#    - could get an array of all matchers and then provide a separate
#      function to combine them together as needed?
#  * repo_info('hg', sub { ... })
#    - populates a hash with info about the repo
#    - may register multiple ones of these
#    - how to register as async?  spawns in separate process, stores results
#    - what about invalidation?
#  * something to actually render prompts? conditional on repo type?
#    resolution order...?

# What about something simpler - a "builder" for a prompt line, w/ a simple
# easy-to-read/write/understand format, but with minimal smarts about repo info
#   - pass off repo info to separate tool, which can be customized separately?
#   - other tool could spit out builder, or else json and this tool uses it?
#     given that we want a different-looking prompt for each repo type, it seems
#     like the json approach will be difficult; but who owns the color logic?

# Separate, composable tools seems like a win.
# One tool's business is just rendering colorful prompt lines with information
# in them.  It shouldn't have any logic for picking the colors, etc.  But it does
# need a way to *represent* them.  Input could look like

# ```
# bar {
#   bg #80bc3f
#   style triangle:3
#   filler diag:2
#   bubble {
#     align left
#     margin 3   <-- is this built into something else?
#     bg black
#     fg bold|green
#     text sdh@riose
#   }
#   bubble {
#     align left
#     margin 3
#     bg black
#     text %{yellow}%{lightning}
#   }
#   bubble {
#     align right
#     margin 3
#     bg black
#     fg bold|white
#     text Mon, Dec 18, 11:23:58
#   }
# }
# line {
#   partition {
#     fg bold|blue
#     text ~/src/repoline
#   }
#   partition {
#     margin 1
#     text $
#   }
# }
# ```

# Between partitions (which may have styles or separators to switch between
# different background colors) and bubbles (which use a pair of separators)
# this should handle all cases?  Maybe it's already too redundant in terms of
# configuration options... what about a LaTeX-inspired approach?

# ```
# \def\bubble#1{{\margin{3}\style{triangle}\bg{black}#1}}
# {
#   \bg{#895bfc}
#   \bubble{\fg{green}\bf sdh@riose}
#   \hfill
#   \bubble{\fg{white}\bf Mon, Dec 18, 11:23:58}
# }
# \\
# {\fg{blue}\bf ~/src/repoline}
# {\margin{1}`$`}
# ```

# Then we use a "line builder" approach to figure out spacing and blending?
# Here we're mostly hard-coding the style bits, though we could possibly pull
# out the "header" as an environment thing that could be swapped out as
# needed?  That would provide pretty good separation between content and style
#  - especially if macros are lazy, then we define a constant header, but then
#    in the specific content can fill in `\def\repobg{\bg{#df24cd}}` along with
#    the normal text:
# ```
# \repobg{#df24cd}\left{sdh@riose}\right{Mon, Dec 18, 11:23:58}\path{~/config}
# ```
# or at this point
# ```
# repobg #df24cd
# left sdh@riose
# right Mon, Dec 18, 11:23: 58
# path ~/config
# ```
# This would require a bit more smarts in the formatter, i.e. conditionals for
# empty stuff, etc? But if the format were a perl script that's fed a nested hash
# with data in it, and had access to a number of useful libraries for blending
# backgrounds with given styles (defaulting but overridable, etc) then it could
# be pretty easy...?
#
# ```
# my $bar = $output->line()->set_bg($_->{repobg});
# $bar->child()->bg('black')->fg($_->{left.color} || 'green')
#     ->bold()->text($data->{left}) if $_->{left};
# $bar->hfill();
# $bar->child()->bg('black')->fg(white)->bold()->text($_->{right})
#     if $_->{right};
# ```
#
# Level of nesting indicates whether separators are paired?
# Or could make padding and margin a little less automatic?
#
# margin 2
# padding 1  <-- or add explicit "pad 1": { bg black pad 1 ... pad 1 }
#                in this model, each block or non-block gets padded?
#                - but bottom line shouldn't be!
# style triangle  <-- or flame, or bits, or ...?
# bg $repobg
# if $left
#   { bg black fg green bold $left }
# fi
# hfill
# if $right
#   { bg black fg white bold $right }
# fi
# margin 2
# line
# if $reponame
#   { fg yellow bold $reponame }
#   sep  <-- if not changing bg color, need explicit sep (could have color)
#   { fg blue bold $reporelative }
# else
#   { fg blue bold $path }
# fi
# "$"

# Simpler format:
#  - Multiple args - one for each line
#  - Simple control chars:
#      c() for color, using | to separate attrs, or fg/bg
#      {() } for a bubble, will blend BG colors if different
#        - the } will pop the previous state back
#        - if no args then no delimiters?
#      ... for a fill, will include the fill char if appropriate?
#      >() or <() for a non-grouped delimiter, will also blend
#      s() to change the style in-line (i.e. filler chars, separators, etc)
#        - e.g. s(fill?=hash,sep=triangle), the ?= only sets if not configured
#      "text" for literal non-whitespace text
#  - Maybe not even that
#      {(green/black,b,d?=triangle) "sdh@riose" } ... {(white/black,b,d?=triangle) "..." }
#      >(green,d?=triangle)
#
# '/#00fa46  {!g/k "sdh@riose" }  *  {!w/k "Mon, Dec 18, 11:34:58" }  |!b"~/config"0 "$" '

# '/#00fa46  {!g/k "sdh@riose" }  *  {!w/k "Mon, Dec 18, 11:34:58" }  |!b"~/config"0 "$" '


# 'c(/#00fa46)  {(green/black|b) "sdh@riose" }  ...  {(white/black|b) "Mon, Dec 18, 11:34:58" }  '
# 'c(blue|b)"~/config"c() "$" '


sub main {
  my $cmd = shift;
  die 'Usage: repoline prompt' unless $cmd eq 'prompt';
  do_prompt(@_);
}

sub help {
  # TODO(sdh): add a proper help page.
  print STDERR "@_\n";
  exit 1;
}

# Reads arguments, either from 
sub read_args {
  my %args = %{shift()};
  for my $key (keys %args) {
    my $env = uc "repo_$key";
    $env =~ s/^--|:$//g;
    ${$args{$key}} = $ENV{$env} if defined $ENV{$env};
  }
  while ($_ = shift) {
    help("Unknown arg: $_") unless s/^--//;
    if (defined $args{"$_:"}) {
      # TODO(sdh): consider allowing optional arg and not choking?
      ${$args{"$_:"}} = 1;
      next;
    }
    unshift @_, $1 if s/^--[^=]+\K=(.*)$//;
    help("Unknown arg: --$_") unless defined $args{$_};
    ${$args{$_}} = shift;
  }
}

my $repo_dirs = '.git:.hg';
# Returns a list of repo directory names that can appear in repo roots.
sub repo_dirs {
  # Default to .git and .hg, but can add more with environment variable.
  return split /:/, $repo_dirs;
}

sub is_zsh {
  return $ENV{SHELL} =~ m|/zsh$|;
}

# Open and close brackets for non-printing characters
# (Turn on/off globally for now?)
my @shell_npc = is_zsh() ? qw/%{ %}/ : qw/\[ \]/;

# Finds the root of the current directory's repository.
sub root {
  my $dir = cwd();
  my @repo_dirs = repo_dirs();
  while (length $dir > 1) {
    for (@repo_dirs) {
      return $dir if -e "$dir/$_";
    }
    $dir = dirname($dir);
 }
  return '';
}

# TODO(sdh): Add more fonts for styles
#   http://www.fontspace.com/category/patterns
#    - a number of options here
#   http://www.fontspace.com/agasilva/maya-tiles-promo
#    - would need to auto-download and merge with nerd font...
# Might be able to put together a little font for this...?

sub do_prompt {
  # Handle args
  my $notouch = 1;
  my $columns = 0;
  my $left = '%fG%u@%h';
  my $right = '%fW%t';
  my $prompt = '%fB%W%f0 $ ';
  my $style = 'DEFAULT';
  my $flag_fg = '';
  my $flag_bg = '';
  my $sep = 'TRIANGLE';
  read_args {
      'notouch:' => \$notouch,
      columns => \$columns,
      left => \$left,
      right => \$right,
      prompt => \$prompt,
      style => \$style,
      fg => \$flag_fg,
      bg => \$flag_bg,
      sep => \$sep,
      dirs => \$repo_dirs,
  }, @_;
  my $touch = $notouch;
  my $root = root();
  my $colors = $flag_fg && $flag_bg ? '' : find_colors($touch, $root);
  my ($bg, $fg, $ansi_bg, $ansi_fg) = split / /, $colors;
  $ansi_bg = $flag_bg if $flag_bg;
  $ansi_fg = $flag_fg if $flag_fg;

  my $escapes = 0;
  $prompt = expand($prompt);
  @shell_npc = ('', '') unless is_zsh();
  $left = expand($left, \$escapes);
  $right = expand($right, \$escapes);

  my %STYLES = (
    DIAG => sub { my $r = int(rand() * 4); return $r ? chr($r + 0x2570) : ' ';  },
    BOX => sub { return chr(int(rand() * 10) + 0x2596); },
    FLAG => sub { return chr(int(rand() * 8) + 9776); },
    TRAIN => sub { return '#'; },
    DEFAULT => sub { return ' '; },
  );
  die "No such style: $style" unless defined $STYLES{uc $style || 'DEFAULT'};
  $style = $STYLES{uc $style || 'DEFAULT'};

  my %SEP = (
    TRIANGLE => [0xe0b2, 0xe0b0],
    ROUND => [0xe0b6, 0xe0b4],
    DOWN => [0xe0be, 0xe0b8],
    UP => [0xe0ba, 0xe0bc],
    SPLIT => [0xe0d4, 0xe0d2],
    #RSPLIT => [0xe0d2, 0xe0d4], # TODO - needs swap fg/bg
    FIRE => [0xe0c2, 0xe0c0],
    DISSOLVE => [0xe0c7, 0xe0c6], # smaller one (5,4) ugly at console font size
    NONE => [0x20, 0x20],
  );
  die "No such separator: $sep" unless defined $SEP{uc $sep || 'TRIANGLE'};
  my ($open, $close) = @{$SEP{uc $sep || 'TRIANGLE'}};
  $open = chr $open; $close = chr $close;

  my $OSC = "$shell_npc[0]\e[";
  my $m = "m$shell_npc[1]";

  $columns = `tput cols`, chomp $columns unless $columns;
  my $dashes = $columns - length($left) - length($right) + $escapes;
  my $out = is_zsh() ? \*STDOUT : \*STDERR; # TODO(sdh): argument to make this STDERR ?
  if ($ansi_bg eq '0') { # NOTE: currently never runs, since we changed the blank default
    print $out "${OSC}1;30${m}———($OSC$m$left$OSC$m${OSC}30$m)";
    print $out '—' x ($dashes - 10);
    print $out "($OSC$m$right${OSC}30$m)———$OSC$m";
  } else {
    # TODO(sdh): figure out if terminal is running powerline fonts (maybe just a list of
    # known terminals that do support it?). Fall back on parens or something else?
    binmode $out, ":utf8";
    #my ($open, $close) = (chr 0xe0b2, chr 0xe0b0);
    my $main = "${OSC}1;3${ansi_fg};4${ansi_bg}$m";
    $open = "$OSC$m${OSC}30;4${ansi_bg}$m  ${open}";
    # $close = "${OSC}1;38;2;0;0;0;4${ansi_bg}$m${close}${main} ";
    $close = "${OSC}30;4${ansi_bg}$m${close}${main} ";
    $dashes -= 8 if $left;
    $dashes -= 8 if $right;
    $left = "${open}$OSC$m ${left} $OSC$m${close} " if $left;
    $right = "${open}$OSC$m ${right} $OSC$m${close} " if $right;
    print $out $main;
    print $out $left;
    print $out (&$style()) for (1..$dashes);
    print $out $right;
    print $out "$OSC$m";
  }
  print $prompt;
}

sub do_colors {
  # Handle args
  my $touch = 1;
  my $get_fg = 1;
  my $get_bg = 1;
  my $ansi = 0;
  while ($_ = shift) {
    unshift @_, $1 if s/^--[^=]+\K=(.*)$//;
    $touch = 0, next if $_ eq '--notouch';
    $get_fg = 0, next if $_ eq '--bg';
    $get_bg = 0, next if $_ eq '--fg';
    $ansi = 1, next if $_ eq '--ansi';
    help(1);
  }
  my $root = root();
  my $colors = find_colors($touch, $root);
  my ($bg, $fg, $ansi_bg, $ansi_fg) = split / /, $colors;

  # Now print what was asked for.
  $fg = $ansi_fg if $ansi;
  $bg = $ansi_bg if $ansi;
  print $fg if $get_fg;
  print ":" if $get_fg and $get_bg;
  print $bg if $get_bg;
  print "\n";
  exit;
}

# Colors.
my @COLORS = (
  ['PaleVioletRed',	'#ff82ab', '#8b475d'],
  ['MediumOrchid',	'#e066ff', '#7a378b'],
  ['MediumPurple',	'#ab82ff', '#5d478b'],
  ['DodgerBlue',  	'#2090ff', '#104e8b'], # 2/256 more red
  ['SkyBlue',    	'#87ceff', '#4a708b'],
  ['turquoise', 	'#00f5ff', '#00868b'],
  ['aquamarine', 	'#7ffcd4', '#458b74'],
  ['green',     	'#04f900', '#008b00'],
  ['DarkOliveGreen', 	'#a2cd5a', '#6e8b3d'],
  ['gold',      	'#ffd700', '#8b7500'],
  ['burlywood', 	'#ffd39b', '#8b7355'],
  ['LightSalmon', 	'#ffa07a', '#8b5742'],
  ['DarkOrange',    	'#ff7f00', '#8b4500'],
  ['tomato',    	'#ff6347', '#8b3626'],
);

# Usage: find_colors $touch, $root
sub find_colors {
  # Find directory
  local $_;
  my ($touch, $root) = @_;
  # my $blank = '#000000 #666666 0 7';
  my $blank = '#000000 #666666 ' . to_ansi('#666666') . ' ' . to_ansi('#000000'); #8;2;0;0;0 8;2;255;255;255';
  return $blank unless $root;
  (my $root_scrubbed = $root) =~ s|/|!|g; # don't worry about collisions
  my $dir = $ENV{REPO_COLOR_DIR} || "$ENV{HOME}/.repo_colors";
  mkpath [$dir], 1, 0755 unless -d $dir;
  my $file = "$dir/$root_scrubbed";
  my $color;
  if (-e $file) {
    $color = read_file($file);
    system 'touch', $file;
  } else {
    return $blank unless $touch; # if --notouch then don'just return empty.
    # Make a new file, may need to expire older ones.
    opendir DIR, $dir;
    my @files = ();
    while ($_ = readdir DIR) {
      next if /^\.\.?/;
      push @files, ["$dir/$_", -C "$dir/$_"];
    }
    closedir DIR;
    @files = sort { $a->[1] <=> $b->[1] } @files;
    # Truncate down to 10
    while (@files > 10) {
      my $file = (pop @files)->[0];
      unlink "$dir/$file";
    }
    my @colors = map { read_file($_->[0]) } @files;
    $color = pick_color(@colors);
    open FILE, '>', $file or die "Could not open $file: $!";
    print FILE $color;
    close FILE;
  }
  # $color now holds an index into @COLORS
  my $bg = $COLORS[$color]->[1];
  my $fg = $COLORS[$color]->[2];
  my $ansi_bg = to_ansi($bg);
  my $ansi_fg = to_ansi($fg);
  return "$bg $fg $ansi_bg $ansi_fg";
}

sub to_ansi {
  local($_) = shift;
  s/^#//;
  my @parts = ('8;2');
  while (s/^(..)//) {
    push @parts, hex $1;
  }
  return join ';', @parts;
}

sub read_file {
  open FILE, '<', $_[0] or die "Could not open file $_[0]: $!";
  my $line = <FILE>;
  chomp $line;
  close FILE;
  return $line;
}

sub pick_color {
  # Ideally we would parse the colors, map to L*a*b* color space, and then
  # measure absolute differences.  But given the device-dependence of RGB,
  # this turns out to be ridiculously hard, so I won't bother.
  my @PENALTIES = (
    ['PaleVioletRed', 'MediumOrchid', 2],
    ['MediumOrchid', 'MediumPurple', 8],
    ['MediumPurple', 'DodgerBlue', 2],
    ['MediumPurple', 'SkyBlue', 1],
    ['DodgerBlue', 'SkyBlue', 1],
    ['SkyBlue', 'turquoise', 8],
    ['SkyBlue', 'aquamarine', 2],
    ['turquoise', 'aquamarine', 8],
    ['turquoise', 'green', 2],
    ['aquamarine', 'green', 8],
    ['aquamarine', 'DarkOliveGreen', 2],
    ['green', 'DarkOliveGreen', 2],
    ['DarkOliveGreen', 'gold', 2],
    ['gold', 'burlywood', 8],
    ['gold', 'LightSalmon', 1],
    ['burlywood', 'LightSalmon', 8],
    ['LightSalmon', 'DarkOrange', 4],
    ['LightSalmon', 'tomato', 2],
    ['DarkOrange', 'tomato', 8],
    ['LightSalmon', 'PaleVioletRed', 1],
    ['DarkOrange', 'PaleVioletRed', 4],
    ['tomato', 'PaleVioletRed', 4],
    ['tomato', 'MediumOrchid', 1],
  );
  my %COLORS = ();
  $COLORS{$_->[0]} = 1 for (@COLORS);
  my %PENALTIES = ();
  for (@PENALTIES) {
    my ($a, $b, $c) = @$_;
    die "Bad color: $a" unless defined $COLORS{$a};
    die "Bad color: $b" unless defined $COLORS{$b};
    $PENALTIES{"$a $b"} = $PENALTIES{"$b $a"} = $c;
  }

  # Iterate through all the not-picked colors
  my %options = ();
  $options{$_} = 0 for (1..$#COLORS);
  delete $options{$_} for (@_);
  my @costs = ();
  for (keys %options) {
    my $a = $COLORS[$_]->[0];
    my $cost = 0;
    my $multiplier = 1024;
    for my $x (@_) {
      my $b = $COLORS[$x]->[0];
      $cost += ($PENALTIES{"$a $b"} || 0) * $multiplier;
      $multiplier /= 2;
    }
    push @costs, [$_, $cost];
  }
  @costs = sort { $a->[1] <=> $b->[1] } @costs;
  return $costs[0]->[0];
}

# Expands prompt text.
sub expand {
  local($_) = shift;
  my $escapes = shift;
  # TODO(sdh): support more args?
  $_ =~ s/%([uhHtW%]|[fb].)/expand_char($1, $escapes)/eg;
  return $_;
}

sub expand_char {
  local($_) = shift;
  my $escapes = shift;
  return '%' if $_ eq '%';
  return $ENV{USER} if $_ eq 'u';
  return long_host() if $_ eq 'H';
  return short_host() if $_ eq 'h';
  return date_time() if $_ eq 't';
  return short_dir() if $_ eq 'W';
  if (/^[fb]0$/) {
    $$escapes += 3;
    return "$shell_npc[0]\e[m$shell_npc[1]";
  }
  if (s/^([fb])//) {
    my $base = $1 eq 'f' ? 3 : 4;
    my $code = "$shell_npc[0]\e[";
    $code .= '1;' if y/A-Z/a-z/;
    my %colors = (r=>1, g=>2, y=>3, b=>4, m=>5, c=>6, w=>7);
    # TODO - access to repo colors?!?
    return unless defined $colors{$_}; # TODO - error?
    $code .= $base;
    $code .= ($colors{$_} || 0);
    $code .= "m$shell_npc[1]";
    $$escapes += length($code);
    return $code;
  }
  return '';
}

# TODO(sdh): Find a better way to branch these.

sub long_host {
  my $host = $ENV{HOST} || `hostname`;
  chomp $host;
  return $host;
}

sub short_host {
  my $host = long_host();
  $host =~ s/\..*//;
  return $host;
}

sub date_time {
  # TODO(sdh): Consider allowing custom format via env var?
  my $date = `date +'%a, %b %-d, %T'`;
  chomp $date;
  return $date;
}

sub short_dir {
  my $pwd = $ENV{PWD};
  $pwd =~ s/^$ENV{HOME}/~/;
  return $pwd;
}

# Just do it,
main(@ARGV);
